
## API
* 엔티티 필드를 바꾸게되면 api 스펙이 바뀌어버리게된다.
* 엔티티를 여러곳에서 사용하기 때문에 필드명을 바뀌어버리게되면 대규모 수정이 일어남
* 회원 정보만 원하는데, 엔티티를 주게되면 원치않는 값들을 주게된다.
* api스펙에 맞춰서 DTO를 사용해서 해결한다
  * DTO를 보면 api 스펙을 볼 수 있다. (가독성 상승) valid 조건 적용가능
  * entity를 외부로 노출하지 않음

#### 회원 등록, 수정, 조회 API 개발 완료  

## API 개발 고급

* 조회용 샘플 데이터 입력
* 지연로딩과 조회 성능 최적화
* 컬렉션 조회 최적화
* 페이징과 한계 돌파
* OSIV와 성능 최적화


## 지연로딩과 조회 성능 최적화
* 주문 + 배송정보 + 회원을 조회하는 api 개발
* 지연로딩 때문에 발생하는 성능문제를 단계적 해결

### 실무 100% 과정

1. 간단한 주문조회 V1 : 엔티티를 직접 노출
2. DTO 로 조회 V2 : N+1 성능문제 발생, 쿼리가 너무많이 나감
3. 페치조인 최적화 V3 : 많은 select 문을 날림 -> **v4 비교해서 성능테스트 미비함!**
4. new 명령어로 DTO로 원하는 데이터만 출력 V4 : 그래프탐색이 없다. , 재사용성이 없다, api 스펙에따라 작성해야됨
5. 

* 엔티티를 DTO 로 변환하거나, DTO 로 바로 조회하는 두가지 방법은 장단점이있음
* 쿼리 방식 선택 권장 순서
  * 우선 엔티티를 DTO 변환하는 방법 선택 (v2)
  * 필요하면 페치 조인으로 성능 최적화 (v3)
  * 그래도 안되면 DTO 직접 조회 방법 사용 (v4)
  * 최후의 방법은 JPA 제공하는 네이티브 SQL 이나 스프링 JDBC Template 사용해서 SQL을 직접 사용한다.


### 컬렉션 페치 조인

* JPA distinct 어플리케이션에서 추가 중복을 막아준다
* 단점 : 페이징이 불가능함
  * 일대다 페치조인에서는 페이징 사용 불가능
  * 모든 데이터를 읽어오고 메모리 페이징해버린다(매우위험)
* 컬렉션 페치 조인은 1개만 사용할 수 있다.
  * 둘 이상 사용시 데이터가 부정합하게 조회 될 수 있다.


## 페이징과 한계돌파
* 페이징 + 컬렉션 엔티티를 함께 조회하려면 어떻게 해야할까?
* 코드도 단순하고, 성능최적화도 보장하는 매우 강력한 방법
* 페이징 + 컬렉션 엔티티 조회문제는 이방법으로 해결 가능
1. ToOne 관계를 모두 페치 조인 한다. (row수를 증가시키지 않기때문)
2. 컬렉션은 지연로딩으로 조회한다.
3. 지연로딩 성능 최적화를 위해 default_batch_fetch_size, @BatchSize 를 활용
  * in 쿼리로 컬렉션 내용을 batchsize 만큼 가져온다
  * application.yml 에서 하이버네이트 batch size 로 글로벌 설정
  * @BatchSize(size= ?) 로 개별 최적화
  * **이 옵션 사용시 컬렉션이나 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회**

### 장점 
  * 쿼리 호출수가 1+n -> 1+1 로 최적화
  * 조인보다 DB 전송량이 최적화
  * 쿼리 호출 수가 약간 증가하지만 DB 전송량이 감소함
  * 페이징이 가능하다
### 결론
  * ToOne 관계는 페치 조인해도 페이징 영향을 주지않는다. 따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고
  * 나머지는 batch size로 최적화 하자

### 적당한 size는 어떻게 해야되는가
  * max 1000 개 넘어 갈 시 DB 에러가 나타 날 수 있으므로 되도록 1000 개 미만으로 정하는게 좋음
  * 100~1000 사이 선택을 권장함
  * DB 마다 in 절 파라미터 제한이 있기 때문에 종류에 따라 선택해야된다.
  * 결론은 어플리케이션 순간 부하를 어느정도 견딜 수 있는지에 따라 정하면된다.
  