## 엔티티 설계

### 설계 시 주의사항

### 가급적 setter 사용하지 말자
  * 열려 있으면 변경포인트가 너무 많고 유지보수가 어려워진다.
### 모든 연관관계는 지연로딩으로 설정
  * 즉시로딩(EAGER)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다.
  * 특히 JPQL을 실행할 때 N+1 문제 발생
    * n개를 조회할때 n+1 쿼리가 날라가는 현상
  * 실무에서는 지연로딩으로 설정해야된다.
  * 연관된 엔티티를 함께 DB에서 조회해야하면, 페치조인 또는 엔티티 그래프 기능 사용
  * @XToOne 관계는 기본이 즉시 로딩이므로 직접 지연로딩으로 설정해야됨
### 컬렉션은 필드에서 초기화하자
  * 컬렉션은 필드에서 바로 초기화 하는것이 안전하다.
  * null 문제에서 안전
  * 하이버네이트는 엔티티 영속화할때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다.
  * 만약 getOrders() 처럼 임의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 매커니즘 문제가 발생 할 수 있다.
  * 따라서 필드레벨에서 생성하는것이 가장 안전하고, 코드도 간결하다.
```java
Member member = new Member();
sout(member); // Member 타입
em.persist(member);
sout(member); // 컬렉션 내용이 다름
```
### 테이블, 컬럼명 생성 전략
* SpringPhysicalNamingStrategy (스프링부트 기본 전략)
  * 카멜케이스 -> 언더스코더(memberPoint -> member_point)
  * .(점) -> _(언더스코더)
  * 대문자 -> 소문자



  